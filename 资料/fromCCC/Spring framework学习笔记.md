# Spring framework学习笔记

对于每个知识点我都整理为：用来解决什么问题、基本概念、怎么解决问题、注意事项四部分。

## Spring ioc & di

### 解决什么问题

+ Spring本身就是为了简化Java web开发而生的框架。而Java中有大量的类，类与类之间有很多依赖关系，尤其是由`new`直接创建实例带来的强耦合，使得修改代码时非常麻烦。
+ 接上条，有些依赖关系甚至会产生**环**的结构，让人头大。
+ 且由于Java的语言特性，程序员可以在任意位置使用`new`，这样看上去就感觉很乱。
+ 对于有些类，我只想调用它的方法，但不想声明成static（因为具体的实现逻辑中可能会用到一些非static的东西），则必须要先生成它的一个实例才能调用这个方法。而对于另一部分类。
+ 对于有些类，我希望它的生命周期是可控的，能不能仅通过配置一个属性就让框架帮我管理呢？

基于以上原因，人们希望能够找到一种可以统一控制所有`new`的框架，并能管理这些被new出来的东西，“剥削”掉程序员自己主动`new`的权利，这个神奇的框架就可以避免类直接的直接引用（依赖），从而解藕。

进一步的，既然程序员把自己`new`的权利抛弃了，那么我怎么给这些转移了控制权的类增加依赖呢（尤其是上述的相互依赖）？为了针对性解决上述类和类之间的依赖关系以及其他相关初始化的操作，框架还需要能够将依赖“注入”的能力，且“注入”的时机我们希望从编译期延后到运行期（如果出错就抛异常），毕竟被复杂的依赖关系搞得编译都不能通过是件很尴尬的事。

所以，Spring框架就给出了它的解决方案。

### 基本概念

由上，可以知道程序员的主动控制权被框架“剥削”了，大部分的`new`都强制（也并不算强制，但既然用了Spring还是老老实实少用`new`）交给框架处理，因此这实际上是一种**控制反转**（IOC），以及对依赖的管理——**依赖注入**（DI）。

Spring就是通过灵活运用工厂模式，通过反射机制和各种工厂实现了统一生产`bean`（所有由IOC控制生产并维护的实例都是`bean`）。

依赖注入(`Dependency Injection`)是spring框架核心ioc的具体实现。之前我们已经通过控制反转把创建对象的权利转交给Spring，但是一些对象中不可避免地定义了一些其他类的对象作为属性，比如controller中有service的实现类、service中有repository的实现类，众所周知，如果方法没有`static`前缀，则必须实例化一个对象才能调用其方法。我们同样不希望在这些类中给这些属性用`new`来初始化，因此这就需要**依赖注入**，主要分为构造函数注入和set方法注入这两种。

### 怎么解决问题

我们希望工程在任何时候都能编译通过，即使有错误也希望通过抛出异常的方式来被发现，同时也不希望代码中有大量的硬编码。因此最直接的解决方法就是把所有需要硬编码的部分写成`xml`配置文件，然后让框架去解析。对应到这里，就是写一个名为`bean.xml`的配置文件，把之前所述的需要转交创建控制权的对象都配置在这个文件中，然后框架就能按照文件中所填写的信息自动进行ioc和di的相关工作。

另一种方法就是使用注解。注解的本质和`xml`一样，都是提供一种配置信息，但不同的是`xml`需要事先写好，当代码有变化时可能需要及时修改其中的相关信息。而注解却是在写代码时顺手加上去的，让编译器帮我们自动生成配置信息，我个人感觉使用注解更加灵活。目前我在项目中使用的ioc和di相关注解主要有`@Controller`， `@Service`， `@Mapper`, `@Component`，`@Configuration`, `@Autowired`, `@Resource`等：

- 前三者分分别用于注解在controller，service，mapper类上，将他们注册成bean，一遍能够在三层架构中互相调用。第四个单纯表示被注解的是一个bean。个人感觉除了名字不同，这几个注解并无本质区别。
- `@Configuration`注解我的理解是相当于一个`beam.xml`文件，里面可以通过`@Bean`方法注册bean（虽然其他地方也可以通过该注解注册bean，但我阅读了一些工程源码，一般都是集中定义在`@Configuration`注解的类中。特别地，对于Springboot项目，可以通过继承相应的adapter类重写相应的方法来实现一些自定义的配置。
- 最后两者则是用来进行依赖注入的。autowired是懒人用法，会自动在已经注册的bean中寻找适合注入的bean注入的被注解的属性中，但是对于有多个实现类的bean，比如一个service接口可能有多个实现类，此时若将属性声明成接口类型，则必须用resource来指定注入哪个实现类。

除了帮忙生成实例，ioc还可以帮我们管理bean的生命周期。例如controller类只是提供API，其提供的服务都是一样的，没有必要生成多个实例，因此它的scope是`singleton`。还有`prototype`，与`singleton`是相对的，即每次其他地方需要注入这个依赖时框架都会新建一个实例注入，然后框架就不再管它了（因为程序员可能任意多地进行依赖注入，如果都交给框架管理会造成大量资源浪费）。还有`request`，`session`，`global session`，可以很容易从这些名字看出它们表示的bean的作用域。那么此时又引入了一个新的问题，**不同作用域之间的bean的依赖是否会有限制**，显然将作用域长的bean注入到作用域短的bean和从作用域短的bean注入到作用域长的bean是不同的。

### 注意事项

#### 被注册为bean的类需要提供无参构造函数

配置托管给spring的对象，默认情况下调用类的**无参构造函数**，如果没有无参构造函数则不能创建成功。

#### 不要把作用域短的bean注入到作用域长的bean中

当作用域长的bean注入到作用域短的bean中时，似乎没有问题，因为被注入的bean总是在注入的bean的作用域范围内，在其销毁前，依赖始终是有效的。

而反向操作则会有大问题，很可能会导致无效的注入，应该尽量避免。若不可避免地需要引入作用域更短的依赖，应该制定代理模式为**ScopedProxyMode.INTERFACE**，让作用域长的被注入bean能够以代理的形式调用注入的bean，让框架在运行时控制具体其调用的具体是哪个bean实例。

#### 不要乱用spring-boot-dev-tools

spring-boot-dev-tools这个东西在用idea创建springboot项目时往往会自动引入。他会改变一些类加载器，导致融合其他框架时发生错误。

## Spring aop

### 解决什么问题

- 在service层写业务逻辑时，往往需要处理很多异常（甚至很多异常并没有被发现，直到后期维护的时候才被发现），程序员往往需要使用很多的try catch语句。
- 与数据库交互的时候需要进行很多事务控制。
- 控制台的日志输出。
- 以上所有的代码如果没有aop，都需要和业务代码写在一起，导致出现**本末倒置**的情况。当然除了以上集中应用场景，还有权限控制、缓存等等。

基于以上原因，我们希望能够把除了业务之外的代码抽取出来，保持业务代码的*干净*，所以提出了aop的概念。

### 基本概念

为了把业务代码之外的部分抽取出来，就需要把业务方法**切开**（就像外科手术一样），然后把业务无关代码拿走。被切开的地方，就可以称为**切入点**（pointcut），被拿走的业务无关代码被放在**增强/通知**（advice）中，这两者的结合就是**切面**（aspect），而让分开的业务代码和业务无关代码依然能协同工作的步骤称为**织入**（weaving）。

应用中所有可以被切开的地方都称为**连接点**（joinpoint），我的理解切入点是连接点的子集。

### 怎么解决问题

ioc应用的是工厂模式，而aop应用的则是另一种著名的设计模式，代理模式。实际上在之前说明bean的作用域时已经说明其依赖注入可以通过代理接口或者代理类实现，即被调用者和实际提供服务的并不是同一个对象，也就是在将被调用的对象之前加一个**中间人**的角色。传统的静态代理是一个中间人，对应一个实现类，而且必须要在编码阶段由程序员写好，因此很麻烦，所以感觉很少有人直接用静态代理。而动态代理则是通过反射，动态地根据需要被代理的方法创建临时的代理类，从而大大简化了编码的麻烦程度。因此aop的织入操作，我简单理解为生成一个业务方法的动态代理，然后这个代理就负责管理这个业务方法的相关增强和业务代码本身进行协同工作，从而实现它原来的功能。

类似于之前的ioc，aop也可以通过`xml`文件和注解的方式进行应用。具体用法可查阅相关文档。springboot提供了很多可供直接使用的aop注解，如`@ControlerAdvice`，`@ExceptionHandler`等等。但还有些需要程序员手动编写切面配置。

### 注意事项

#### springboot项目中使用aop需要在启动类或配置类上加上`@EnableAspectJAutoProxy`的注解

若不加上此注解，则无法使用自定义切面。

#### 若一个切入点与多个增强相关联，一般需要指定执行顺序

可以通过`@Order`指定切面执行的顺序，该顺序与具体的业务逻辑有关。

## Spring JdbcTemplate和事务管理

### 解决什么问题

- Java提供的jdbc使用起来非常繁琐（注册驱动、建立连接`connection`、创建运行sql语句`statement`、运行语句、处理运行结果`resultset`、释放资源），需要程序员手动控制处理资源的处理和释放，而且其调用的方式往往都是固定的。所以我们希望有一种统一帮我们处理这些的东西，以简化代码开发。

- 简单的增删改查语句不能实现事物级的控制，否则程序员需要手写大量的sql语句，加大了编码的工作量，且容易出错。因此我们希望框架能够提供帮助管理事务的工具。

### 基本概念

- `JdbcTemplate`是Spring框架中提供的一个对象，对原始的JDBC API进行简单封装。

- 事务的四大特性**ACID**：

  - `原子性`(`Atomicity`)： 事务包含的所有操作要么全部成功，要么全部失败回滚;成功必须要完全应用到数据库,失败则不能对数据库产生影响。

  - `一致性`(`Consistency`)：事务执行前和执行后必须处于一致性状态。例如:转账事务执行前后,两账户余额的总和不变。

  - `隔离性`(`Isolation`)：多个并发的事务之间要相互隔离。

  - `持久性`(`Durability`)：事务一旦提交，对数据库的改变是永久性的.

- 事务的隔离级别：

  - `ISOLATION_READ_UNCOMMITTED` ：读未提交.事务中的修改,即使没有提交,其他事务也可以看得到.会导致`脏读`,`不可重复读`,`幻读`.

  - `ISOLATION_READ_COMMITTED`：读已提交(`Oracle`数据库默认隔离级别).一个事务不会读到其它并行事务已修改但未提交的数据.避免了`脏读`,但会导致`不可重复读`,`幻读`.

  - `ISOLATION_REPEATABLE_READ`：可重复读(`Mysql`数据库默认的隔离级别).一个事务不会读到其它并行事务已修改且已提交的数据,(只有当该事务提交之后才会看到其他事务提交的修改).避免了`脏读`,`不可重复读`,但会导致`幻读`.

  - `ISOLATION_SERIALIZABLE`：串行化，事务串行执行,一个时刻只能有一个事务被执行.避免了`脏读`,`不可重复读`,`幻读`.

- 事务的安全隐患有如下三种：

  - `脏读`：一个事务读到另外一个事务还未提交(可能被回滚)的脏数据.

  - `不可重复读` ：一个事务执行期间另一事务提交修改,导致第一个事务前后两次查询结果不一致.

  - `幻读`：一个事务执行期间另一事务提交添加数据,导致第一个事务前后两次查询结果到的数据条数不同.

### 怎么解决问题

- `JdbcTemplate`使用了模板方法的设计模式，同时结合了回调方法的使用。简单来说，就是将待执行的`statement`委托给jdbctemplate，而jdbctemplate中已经按照步骤处理了上述运行语句步骤之前和之后的所有步骤（其中注册驱动是在ioc创建jdbctemplate的bean时通过配置文件的方法加载了实现了Java数据库相关的spi的包），而运行语句这一步以回调函数的形式出现，因此程序员只需要给jdbctemplate类传入一条sql语句即可执行它，不再需要处理前后繁琐的工作。
- Spring框架采用aop进行事务管理。通过对一个事务管理器bean进行aop（在其中设置切入点）配置，集中管理所有的事务。可以通过`xml`配置文件配置，也可以通过注解的形式进行配置，个人觉得注解配置更加灵活，通过`@Transactional`标示要对哪些接口（接口中的所有方法）和哪些方法进行事务控制，同时可以设置事务管理的相关参数。

### 注意事项

#### springboot项目中要使用注解进行事务控制需要添加`@EnableTransactionManagement`注解以开启事务控制

需要在启动类或者相关配置类上进行注解。